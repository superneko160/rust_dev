/**
 * 以下はライフタイムの指定（a'）がないとエラーになる
 * 正確には、関数の返り値の参照が、引数のどの参照からきているか判断できないためエラーになる
 *
 * Rustの参照（&）は、それが指すデータが有効である期間（ライフタイム）を持つ
 * ここで重要なのは関数の返り値も参照である点
 * 参照を返すということは、その参照を指すデータが、関数を呼び出したあとも有効でなければならないことを意味する
 *
 * get_longest_string()はs1かs2を返すが、コンパイラには返される参照がs1のライフタイムに依存するのか、s2のライフタイムに依存するのかがわからない
 *
 * このあいまいさを回避するために、プログラマがコンパイラに対して
 *「この参照は、これらの入力参照のライフタイムのうち、もっとも短いものと同じライフタイムを持つ」
 * と教えてあげるのがライフタイムアノテーション
 */
fn get_longest_string<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    if s1.len() > s2.len() {
        s1
    } else {
        s2
    }
}

fn main() {
    let string1 = String::from("短い");
    let string2 = "これは長い文字列です";  // &strリテラル
    let result = get_longest_string(&string1, string2);
    println!("長い文字列: {}", result);
}
