# ストラテジパターン

- 交換可能なアルゴリズム
- 特定の振る舞い（アルゴリズム）に依存せず、その振る舞いを別のオブジェクトに委譲することで、実行時に振る舞いを変更できるようにするデザインパターン

サンプルコードでは、「飛ぶ」という振る舞いを独立した部品（ストラテジ）として扱い、鳥の種類ごとに振る舞いを固定するのではなく、動的に切り替えられるようにしている。

## パターンの構成要素

- 振る舞いの定義: `FlyBehaviour` トレイトは、「飛ぶ」という振る舞いを定義する。このトレイトを実装する型は、`fly` メソッドを持つ必要がある
- 具体的な振る舞い: `FlyWithWings` と `FlyNoWay` は、それぞれ `FlyBehaviour` トレイトを実装し、具体的な飛び方を表現する
- 振る舞いを委譲する主体: `Bird` トレイトは、自身の `fly` メソッド内で `FlyBehaviour` トレイトのメソッドを呼び出すことで、実際の振る舞いを委譲している


- `Pigeon` は `Box<dyn FlyBehaviour>` フィールドを持ち、実行時に飛ぶ振る舞いを変更できる
- 一方 `Penguin` は `Box<FlyNoWay>` フィールドで飛ぶ振る舞いが固定されている

## `dyn` と `Box` の役割

### `dyn` キーワード

- `dyn` は、トレイトオブジェクトを作成するために使われる
- トレイトオブジェクトは、 `FlyBehaviour` を実装する任意の型を指すことができる
- これにより、コンパイル時ではなく、実行時にどのメソッドを呼び出すかを決定する動的ディスパッチが可能

### `Box` スマートポインタ

- `dyn FlyBehaviour` は、様々な型のデータを指すため、コンパイル時にサイズが不定になる
- Rustでは、このようなサイズの不定なデータをそのまま構造体のフィールドにすることはできない
- `Box` は、値をヒープに確保し、スタックにはサイズが一定のポインタだけを置くことで、この問題を解決する
- `Box<dyn FlyBehaviour>` とすることで、サイズ不定なトレイトオブジェクトを安全に扱うことができ、 `Pigeon` のように振る舞いを実行時に差し替えられる柔軟な設計が可能になる

## まとめ

このコードは、ストラテジパターンの基本原則である「振る舞いの委譲」を、Rustのトレイトシステムと、`dyn` および `Box` による動的ディスパッチを組み合わせることで実現している。これにより、鳥の種類ごとに振る舞いを固定するのではなく、共通のインターフェースを通じて振る舞いを動的に変更できる、拡張性の高いコードとなっている。
